---
description: Spring Boot中间件集成配置指南 - MySQL、Redis、RabbitMQ、MQTT最佳实践
globs: ["**/application.yml", "**/application.properties", "**/*Config.java", "**/*Repository.java"]
alwaysApply: false
---

# Spring Boot 中间件集成配置

Spring Boot环境中MySQL、Redis、RabbitMQ、MQTT等中间件的配置和使用最佳实践。

## MySQL 数据库配置

### 依赖配置 (pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>com.zaxxer</groupId>
        <artifactId>HikariCP</artifactId>
    </dependency>
</dependencies>
```

### 配置文件 (application.yml)
```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/myapp?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
      auto-commit: true
      idle-timeout: 30000
      pool-name: HikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1

  jpa:
    hibernate:
      ddl-auto: validate
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true
```

### JPA实体配置
```java
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email"),
    @Index(name = "idx_created_date", columnList = "created_date")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(nullable = false, length = 50)
    private String name;
    
    @CreationTimestamp
    @Column(name = "created_date", nullable = false, updatable = false)
    private LocalDateTime createdDate;
    
    @UpdateTimestamp
    @Column(name = "updated_date")
    private LocalDateTime updatedDate;
    
    @Version
    private Long version;
}
```

### Repository层最佳实践
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    @Query(value = "SELECT * FROM users WHERE created_date >= :startDate", 
           nativeQuery = true)
    List<User> findRecentUsers(@Param("startDate") LocalDateTime startDate);
    
    @Modifying
    @Query("UPDATE User u SET u.name = :name WHERE u.id = :id")
    void updateUserName(@Param("id") Long id, @Param("name") String name);
}
```

## Redis 缓存配置

### 依赖配置
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

### 配置文件
```yaml
spring:
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: 0
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 2000ms
      shutdown-timeout: 100ms

  cache:
    type: redis
    redis:
      time-to-live: 600000  # 10分钟
      cache-null-values: false
```

### Redis配置类
```java
@Configuration
@EnableCaching
@RequiredArgsConstructor
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // 使用JSON序列化
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper mapper = new ObjectMapper();
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        mapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, 
                                   ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(mapper);
        
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);
        template.afterPropertiesSet();
        
        return template;
    }
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new Jackson2JsonRedisSerializer<>(Object.class)))
            .disableCachingNullValues();
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .transactionAware()
            .build();
    }
}
```

### 缓存使用示例
```java
@Service
@RequiredArgsConstructor
public class UserService {
    
    private final UserRepository userRepository;
    private final RedisTemplate<String, Object> redisTemplate;
    
    @Cacheable(value = "users", key = "#id")
    public UserResponse findById(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("用户不存在"));
        return UserMapper.toResponse(user);
    }
    
    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
    
    // 手动缓存操作
    public void cacheUserSession(String sessionId, UserSession session) {
        redisTemplate.opsForValue().set(
            "session:" + sessionId, 
            session, 
            Duration.ofMinutes(30)
        );
    }
    
    public UserSession getUserSession(String sessionId) {
        return (UserSession) redisTemplate.opsForValue().get("session:" + sessionId);
    }
}
```

## RabbitMQ 消息队列配置

### 依赖配置
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```

### 配置文件
```yaml
spring:
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: /
    connection-timeout: 15000
    publisher-confirm-type: correlated
    publisher-returns: true
    listener:
      simple:
        acknowledge-mode: manual
        retry:
          enabled: true
          initial-interval: 1000
          max-attempts: 3
          max-interval: 10000
          multiplier: 2
```

### RabbitMQ配置类
```java
@Configuration
@EnableRabbit
public class RabbitConfig {
    
    // 交换机定义
    @Bean
    public TopicExchange userExchange() {
        return ExchangeBuilder.topicExchange("user.exchange")
            .durable(true)
            .build();
    }
    
    // 队列定义
    @Bean
    public Queue userCreatedQueue() {
        return QueueBuilder.durable("user.created.queue")
            .withArgument("x-dead-letter-exchange", "user.dlx")
            .withArgument("x-message-ttl", 60000)
            .build();
    }
    
    @Bean
    public Queue userUpdatedQueue() {
        return QueueBuilder.durable("user.updated.queue")
            .build();
    }
    
    // 死信队列
    @Bean
    public Queue deadLetterQueue() {
        return QueueBuilder.durable("user.dead.letter.queue").build();
    }
    
    @Bean
    public DirectExchange deadLetterExchange() {
        return ExchangeBuilder.directExchange("user.dlx").build();
    }
    
    // 绑定关系
    @Bean
    public Binding userCreatedBinding() {
        return BindingBuilder
            .bind(userCreatedQueue())
            .to(userExchange())
            .with("user.created");
    }
    
    @Bean
    public Binding userUpdatedBinding() {
        return BindingBuilder
            .bind(userUpdatedQueue())
            .to(userExchange())
            .with("user.updated");
    }
    
    @Bean
    public Binding deadLetterBinding() {
        return BindingBuilder
            .bind(deadLetterQueue())
            .to(deadLetterExchange())
            .with("dead.letter");
    }
    
    // 消息转换器
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
        RabbitTemplate template = new RabbitTemplate(connectionFactory);
        template.setMessageConverter(new Jackson2JsonMessageConverter());
        template.setMandatory(true);
        template.setConfirmCallback((correlationData, ack, cause) -> {
            if (!ack) {
                log.error("消息发送失败: {}", cause);
            }
        });
        template.setReturnsCallback(returned -> {
            log.error("消息被退回: {}", returned);
        });
        return template;
    }
}
```

### 消息生产者
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserEventPublisher {
    
    private final RabbitTemplate rabbitTemplate;
    
    public void publishUserCreated(UserCreatedEvent event) {
        try {
            rabbitTemplate.convertAndSend(
                "user.exchange", 
                "user.created", 
                event,
                message -> {
                    message.getMessageProperties().setDeliveryMode(MessageDeliveryMode.PERSISTENT);
                    message.getMessageProperties().setExpiration("60000");
                    return message;
                }
            );
            log.info("用户创建事件已发布: {}", event.getUserId());
        } catch (Exception e) {
            log.error("发布用户创建事件失败", e);
            throw new MessagePublishException("事件发布失败", e);
        }
    }
}
```

### 消息消费者
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class UserEventListener {
    
    private final EmailService emailService;
    
    @RabbitListener(queues = "user.created.queue")
    public void handleUserCreated(
            @Payload UserCreatedEvent event,
            @Header Map<String, Object> headers,
            Channel channel,
            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) {
        
        try {
            log.info("处理用户创建事件: {}", event.getUserId());
            
            // 业务处理
            emailService.sendWelcomeEmail(event.getUserId());
            
            // 手动确认
            channel.basicAck(deliveryTag, false);
            
        } catch (Exception e) {
            log.error("处理用户创建事件失败: {}", event.getUserId(), e);
            try {
                // 拒绝消息，重新入队
                channel.basicNack(deliveryTag, false, true);
            } catch (IOException ioException) {
                log.error("消息确认失败", ioException);
            }
        }
    }
}
```

## MQTT 物联网消息配置

### 依赖配置
```xml
<dependency>
    <groupId>org.springframework.integration</groupId>
    <artifactId>spring-integration-mqtt</artifactId>
</dependency>
```

### 配置文件
```yaml
mqtt:
  broker:
    url: ${MQTT_BROKER_URL:tcp://localhost:1883}
    client-id: ${MQTT_CLIENT_ID:spring-boot-app}
    username: ${MQTT_USERNAME:}
    password: ${MQTT_PASSWORD:}
    clean-session: true
    connection-timeout: 30
    keep-alive-interval: 60
    max-in-flight: 10
  topics:
    sensor-data: "sensors/+/data"
    device-status: "devices/+/status"
    commands: "commands/+"
```

### MQTT配置类
```java
@Configuration
@EnableIntegration
@RequiredArgsConstructor
public class MqttConfig {
    
    @Value("${mqtt.broker.url}")
    private String brokerUrl;
    
    @Value("${mqtt.broker.client-id}")
    private String clientId;
    
    @Value("${mqtt.broker.username}")
    private String username;
    
    @Value("${mqtt.broker.password}")
    private String password;
    
    // MQTT连接工厂
    @Bean
    public MqttConnectorOptions mqttConnectorOptions() {
        MqttConnectorOptions options = new MqttConnectorOptions();
        options.setServerURIs(brokerUrl);
        options.setUserName(username);
        options.setPassword(password.toCharArray());
        options.setCleanSession(true);
        options.setConnectionTimeout(30);
        options.setKeepAliveInterval(60);
        options.setMaxInflight(10);
        return options;
    }
    
    // 发布者配置
    @Bean
    public MqttPahoMessageHandler mqttOutbound() {
        MqttPahoMessageHandler messageHandler = new MqttPahoMessageHandler(
            clientId + "-pub", 
            new DefaultMqttPahoClientFactory()
        );
        messageHandler.setAsync(true);
        messageHandler.setDefaultTopic("default/topic");
        messageHandler.setDefaultQos(1);
        messageHandler.setDefaultRetained(false);
        return messageHandler;
    }
    
    // 订阅者配置
    @Bean
    public MqttPahoMessageDrivenChannelAdapter mqttInbound() {
        MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter(
            clientId + "-sub",
            new DefaultMqttPahoClientFactory(),
            "sensors/+/data", "devices/+/status"
        );
        adapter.setCompletionTimeout(5000);
        adapter.setConverter(new DefaultPahoMessageConverter());
        adapter.setQos(1);
        adapter.setOutputChannel(mqttInputChannel());
        return adapter;
    }
    
    @Bean
    public MessageChannel mqttInputChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public MessageChannel mqttOutputChannel() {
        return new DirectChannel();
    }
    
    @ServiceActivator(inputChannel = "mqttOutputChannel")
    @Bean
    public MessageHandler mqttMessageHandler() {
        return mqttOutbound();
    }
}
```

### MQTT消息处理
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class MqttMessageService {
    
    private final MessageChannel mqttOutputChannel;
    private final DeviceDataRepository deviceDataRepository;
    
    // 发送消息
    public void publishCommand(String deviceId, DeviceCommand command) {
        String topic = "commands/" + deviceId;
        String payload = JsonUtils.toJson(command);
        
        Message<String> message = MessageBuilder
            .withPayload(payload)
            .setHeader(MqttHeaders.TOPIC, topic)
            .setHeader(MqttHeaders.QOS, 1)
            .setHeader(MqttHeaders.RETAINED, false)
            .build();
        
        mqttOutputChannel.send(message);
        log.info("发送设备命令: topic={}, payload={}", topic, payload);
    }
    
    // 接收传感器数据
    @ServiceActivator(inputChannel = "mqttInputChannel")
    public void handleSensorData(Message<String> message) {
        try {
            String topic = message.getHeaders().get(MqttHeaders.RECEIVED_TOPIC, String.class);
            String payload = message.getPayload();
            
            log.info("接收到MQTT消息: topic={}, payload={}", topic, payload);
            
            if (topic.startsWith("sensors/")) {
                handleSensorDataMessage(topic, payload);
            } else if (topic.startsWith("devices/")) {
                handleDeviceStatusMessage(topic, payload);
            }
            
        } catch (Exception e) {
            log.error("处理MQTT消息失败", e);
        }
    }
    
    private void handleSensorDataMessage(String topic, String payload) {
        // 解析topic获取设备ID: sensors/{deviceId}/data
        String deviceId = extractDeviceIdFromTopic(topic);
        SensorData sensorData = JsonUtils.fromJson(payload, SensorData.class);
        
        // 保存传感器数据
        DeviceData deviceData = DeviceData.builder()
            .deviceId(deviceId)
            .dataType("sensor")
            .payload(payload)
            .timestamp(LocalDateTime.now())
            .build();
        
        deviceDataRepository.save(deviceData);
        
        // 检查阈值告警
        checkThresholdAlerts(deviceId, sensorData);
    }
    
    private void handleDeviceStatusMessage(String topic, String payload) {
        String deviceId = extractDeviceIdFromTopic(topic);
        DeviceStatus status = JsonUtils.fromJson(payload, DeviceStatus.class);
        
        log.info("设备状态更新: deviceId={}, status={}", deviceId, status.getStatus());
        
        // 更新设备状态
        updateDeviceStatus(deviceId, status);
    }
    
    private String extractDeviceIdFromTopic(String topic) {
        String[] parts = topic.split("/");
        return parts.length > 1 ? parts[1] : "unknown";
    }
}
```

## 健康检查和监控

### 依赖配置
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

### 配置文件
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  health:
    rabbit:
      enabled: true
    redis:
      enabled: true
    db:
      enabled: true
```

### 自定义健康检查
```java
@Component
public class MqttHealthIndicator implements HealthIndicator {
    
    private final MqttPahoMessageHandler mqttHandler;
    
    @Override
    public Health health() {
        try {
            if (mqttHandler.isRunning()) {
                return Health.up()
                    .withDetail("mqtt", "连接正常")
                    .build();
            } else {
                return Health.down()
                    .withDetail("mqtt", "连接断开")
                    .build();
            }
        } catch (Exception e) {
            return Health.down()
                .withDetail("mqtt", "连接异常: " + e.getMessage())
                .build();
        }
    }
}
```

## 最佳实践总结

### 数据库最佳实践
- 使用连接池（HikariCP）优化性能
- 合理设置JPA配置，避免N+1查询
- 使用索引优化查询性能
- 实体版本控制防止并发冲突

### 缓存最佳实践
- 设置合理的TTL避免缓存雪崩
- 使用缓存空值保护防止缓存穿透
- 监控缓存命中率和性能指标
- 合理使用缓存更新策略

### 消息队列最佳实践
- 使用持久化队列保证消息可靠性
- 配置死信队列处理异常消息
- 实现幂等性处理重复消息
- 监控队列积压和消费速度

### MQTT最佳实践
- 合理设置QoS级别平衡性能和可靠性
- 使用主题过滤器优化订阅性能
- 实现断线重连和消息重发机制
- 监控连接状态和消息吞吐量